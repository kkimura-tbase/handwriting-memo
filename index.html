<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>手書きメモ（PDF注釈 & 自動保存 + 共有）</title>
<link rel="icon" href="data:,">
<style>
  html,body{height:100%;margin:0;font-family:system-ui}
  .app{display:grid;grid-template-rows:auto 1fr;height:100%}
  .toolbar{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;
           padding:.6rem;background:#f6f6f6;border-bottom:1px solid #ddd}
  .toolbar>*{background:#fff;border:1px solid #ddd;border-radius:.5rem;padding:.3rem .6rem}
  #stageWrap{position:relative;height:100%;min-height:360px;background:#fff;overflow:auto;touch-action: pan-x pan-y;}
  canvas{position:absolute;inset:0;width:100%;height:100%;touch-action:none;display:block}
  #pdfLayer{z-index:0}
  #inkLayer{z-index:1}
  #textLayer{z-index:2;position:absolute;inset:0;pointer-events:none}
  .tool-btn{transition:.15s}
  .tool-btn.active{background:#e8f0fe;border-color:#6a9bff;box-shadow:0 0 0 2px #cfe0ff inset}
  .palette button{width:24px;height:24px;border-radius:50%;padding:0;border:2px solid #ccc;cursor:pointer}
  .palette button.sel{box-shadow:0 0 0 3px #444 inset;border-color:#222}
  .textbox{position:absolute;min-width:40px;min-height:24px;padding:2px 4px;outline:none;border:1px dashed transparent;
           white-space:pre-wrap;word-break:break-word;background:transparent;cursor:text;user-select:text}
  .textbox.sel{border-color:#6a9bff;box-shadow:0 0 0 2px #cfe0ff inset;background:rgba(255,255,255,.2)}
  .grabbing{cursor:grabbing;}
  .sep{width:1px;height:1.6rem;background:#ddd;margin:0 .25rem}
  .hint{font-size:.85rem;color:#666;border:none;background:transparent}
</style>
</head>
<body>
<div class="app">
  <div class="toolbar">
    <label>太さ <input id="size" type="range" min="1" max="30" value="4"></label>
    <label>色 <input id="color" type="color" value="#111111"></label>
    <div class="palette" id="palette">
      <button data-color="#000000" style="background:#000000"></button>
      <button data-color="#ff0000" style="background:#ff0000"></button>
      <button data-color="#0000ff" style="background:#0000ff"></button>
      <button data-color="#008000" style="background:#008000"></button>
      <button data-color="#ffa500" style="background:#ffa500"></button>
      <button data-color="#ffff00" style="background:#ffff00"></button>
    </div>
    <button id="penBtn" class="tool-btn" aria-pressed="true">✒️ペン</button>
    <button id="eraserBtn" class="tool-btn" aria-pressed="false">🧽消しゴム</button>
    <button id="textBtn" class="tool-btn" aria-pressed="false">T テキスト</button>
    <button id="handBtn" class="tool-btn" aria-pressed="false">✋移動</button>
    <label>文字 <input id="fontSize" type="number" min="10" max="96" value="18" style="width:4.5rem"></label>
    <label><input type="checkbox" id="penOnly">ペンのみ</label>

    <div class="sep"></div>
    <button id="undoBtn">↶Undo</button>
    <button id="redoBtn">↷Redo</button>
    <button id="clearBtn">🗑 全消去</button>

    <div class="sep"></div>
    <input type="file" id="pdfInput" accept="application/pdf">
    <button id="prevPage">◀</button><span id="pageInfo">-/-</span><button id="nextPage">▶</button>
    <button id="savePNGBtn">PNG保存</button>

    <div class="sep"></div>
    <!-- ここから復活ボタン -->
    <button id="uploadPdfBtn">📤 PDFを公開（GitHub保存）</button>
    <input id="uploadPdfFile" type="file" accept="application/pdf" style="display:none">
    <button id="openPdfUrlBtn">🌐 PDF URLを読み込み</button>
    <button id="copyShareBtn">🔗 共有リンクをコピー</button>
    <!-- ここまで復活ボタン -->

    <span class="hint">（手書きは自動保存／再読込で復元）</span>
  </div>

  <div id="stageWrap">
    <canvas id="pdfLayer"></canvas>
    <canvas id="inkLayer"></canvas>
    <div id="textLayer"></div>
  </div>
</div>

<script type="module">
/* ================== 設定 ================== */
import * as pdfjsLib from './build/pdf.mjs';
pdfjsLib.GlobalWorkerOptions.workerSrc = './build/pdf.worker.mjs';

// Cloudflare Worker
const UPLOAD_ENDPOINT = 'https://pdf-uploader-plain-union-c1fe.kkimura.workers.dev';
const SAVE_ENDPOINT   = UPLOAD_ENDPOINT;
const APP_KEY_PROMPT  = '先生用キー（APP_KEY）を入力してください';

/* ============= 基本参照 ============= */
const dpr = window.devicePixelRatio||1;
const pdfCanvas = document.getElementById('pdfLayer');
const inkCanvas = document.getElementById('inkLayer');
const textLayer = document.getElementById('textLayer');
const pdfCtx = pdfCanvas.getContext('2d');
const inkCtx = inkCanvas.getContext('2d');
const stageWrap = document.getElementById('stageWrap');

const ui = {
  size:document.getElementById('size'),
  color:document.getElementById('color'),
  fontSize:document.getElementById('fontSize'),
  penBtn:document.getElementById('penBtn'),
  eraserBtn:document.getElementById('eraserBtn'),
  textBtn:document.getElementById('textBtn'),
  handBtn:document.getElementById('handBtn'),
  penOnly:document.getElementById('penOnly'),
  undoBtn:document.getElementById('undoBtn'),
  redoBtn:document.getElementById('redoBtn'),
  clearBtn:document.getElementById('clearBtn'),
  pdfInput:document.getElementById('pdfInput'),
  prev:document.getElementById('prevPage'),
  next:document.getElementById('nextPage'),
  info:document.getElementById('pageInfo'),
  savePNGBtn:document.getElementById('savePNGBtn'),
  paletteWrap:document.getElementById('palette'),
  paletteBtns:document.querySelectorAll('#palette button'),
  // 復活ボタン
  uploadPdfBtn:document.getElementById('uploadPdfBtn'),
  uploadPdfFile:document.getElementById('uploadPdfFile'),
  openPdfUrlBtn:document.getElementById('openPdfUrlBtn'),
  copyShareBtn:document.getElementById('copyShareBtn'),
};

/* ============= 色ヘルパ ============= */
function toHexColor(c){
  if(!c) return '#111111';
  c=String(c).trim().toLowerCase();
  if(c.startsWith('#')){ if(c.length===4){const r=c[1],g=c[2],b=c[3]; return `#${r}${r}${g}${g}${b}${b}`;} return c.slice(0,7); }
  const m=c.match(/rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
  if(m){ const to2=n=>Math.max(0,Math.min(255,parseInt(n,10))).toString(16).padStart(2,'0'); return `#${to2(m[1])}${to2(m[2])}${to2(m[3])}`; }
  const NAME={black:'#000000',white:'#ffffff',red:'#ff0000',blue:'#0000ff',green:'#008000',yellow:'#ffff00',orange:'#ffa500',gray:'#808080',grey:'#808080'};
  return NAME[c]||'#111111';
}

/* ============= 状態 ============= */
const state = {
  tool:'pen', color:toHexColor(ui.color.value), size:+ui.size.value,
  drawing:false, last:null, stroke:[], history:[], redoStack:[],
  pdf:null, page:1, totalPages:0,
  scale:1, baseWidth:0, baseHeight:0,
  margin:200, pdfOffsetX:0, pdfOffsetY:0,
  texts:[],
  isPinching:false, touches:new Map(), lastCenter:null, lastDist:0, rafScheduled:false,
  isHandPanning:false, handStart:{x:0,y:0,sl:0,st:0},
  renderTask:null, renderSeq:0,
  activePointerId:null, activePointerType:null,
  penOnly:false,
  currentPdfUrl:null // 共有リンク作成に使う
};

/* ============= 先生/課題/生徒 ID ============= */
let teacherId, assignmentId, studentId;
function ensureIDs(){
  const q = new URLSearchParams(location.search);
  teacherId    = q.get('t') || localStorage.getItem('teacherId') || prompt('先生名（略号）','tanaka');
  assignmentId = q.get('a') || localStorage.getItem('aid')       || prompt('課題コード','ws1');
  studentId    = q.get('s') || localStorage.getItem('studentId') || prompt('生徒ID（学籍番号など）','s001');
  localStorage.setItem('teacherId', teacherId);
  localStorage.setItem('aid', assignmentId);
  localStorage.setItem('studentId', studentId);
}
ensureIDs();

/* ============= ツール切替 ============= */
function setActiveTool(tool){
  state.tool=tool;
  const map={pen:ui.penBtn,eraser:ui.eraserBtn,text:ui.textBtn,hand:ui.handBtn};
  [ui.penBtn,ui.eraserBtn,ui.textBtn,ui.handBtn].forEach(b=>{
    const on=b===map[tool]; b.classList.toggle('active',on); b.setAttribute('aria-pressed',String(on));
  });
  textLayer.style.pointerEvents = (tool==='text')?'auto':'none';
  stageWrap.classList.toggle('grabbing', tool==='hand' && state.isHandPanning);
}
setActiveTool('pen');
function setSelectedPalette(color){
  const hex=toHexColor(color);
  state.color=hex; ui.color.value=hex;
  for(const b of ui.paletteBtns){ b.classList.toggle('sel', b.dataset.color?.toLowerCase()===hex.toLowerCase()); }
  const sel=document.querySelector('.textbox.sel'); if(sel){ sel.style.color=hex; sel.dataset.color=hex; }
}
setSelectedPalette(ui.color.value);

/* ============= レイアウト & 描画 ============= */
function ensureBaseSize(){ if(state.baseWidth && state.baseHeight) return; const cssW=Math.max(600, stageWrap.clientWidth||800); const cssH=Math.round(cssW*1.41421356); state.baseWidth=cssW; state.baseHeight=cssH; }
function contentWidth(){ return state.baseWidth + state.margin*2; }
function contentHeight(){ return state.baseHeight + state.margin*2; }

async function drawPage(){
  ensureBaseSize();
  if(state.renderTask){ try{ state.renderTask.cancel(); }catch{} state.renderTask=null; }
  const seq = ++state.renderSeq;

  if(state.pdf){
    const page = await state.pdf.getPage(state.page);
    const v1 = page.getViewport({scale:1});
    state.baseWidth=v1.width; state.baseHeight=v1.height;
  }

  const W = contentWidth()*state.scale, H = contentHeight()*state.scale;
  pdfCanvas.width=Math.round(W*dpr); pdfCanvas.height=Math.round(H*dpr);
  inkCanvas.width=pdfCanvas.width;   inkCanvas.height=pdfCanvas.height;
  pdfCanvas.style.width=W+'px'; pdfCanvas.style.height=H+'px';
  inkCanvas.style.width=W+'px';   inkCanvas.style.height=H+'px';
  textLayer.style.width=W+'px';   textLayer.style.height=H+'px';

  pdfCtx.setTransform(dpr,0,0,dpr,0,0);
  pdfCtx.fillStyle='#ffffff';
  pdfCtx.fillRect(0,0,pdfCanvas.width/dpr,pdfCanvas.height/dpr);
  pdfCtx.strokeStyle='#e0e0e0'; pdfCtx.lineWidth=1;
  pdfCtx.strokeRect(0.5,0.5,(pdfCanvas.width/dpr)-1,(pdfCanvas.height/dpr)-1);

  if(state.pdf){
    const page = await state.pdf.getPage(state.page);
    const v = page.getViewport({scale:state.scale});
    const offsetX = state.margin*state.scale;
    const offsetY = state.margin*state.scale;
    state.pdfOffsetX = state.margin; state.pdfOffsetY = state.margin;

    pdfCtx.save();
    pdfCtx.translate(offsetX, offsetY);
    try{
      const task = page.render({canvasContext:pdfCtx, viewport:v});
      state.renderTask = task;
      await task.promise;
      if(seq!==state.renderSeq) return;
    }catch(e){} finally{ if(seq===state.renderSeq) state.renderTask=null; pdfCtx.restore(); }
    ui.info.textContent=`${state.page}/${state.totalPages}`;
  }else{
    ui.info.textContent='—/—';
  }
  redrawInk();
  layoutTextboxes();
}
function scheduleDrawThrottle(){ if(state.rafScheduled) return; state.rafScheduled=true; requestAnimationFrame(()=>{ state.rafScheduled=false; drawPage(); }); }

/* ============= Ink（描画） ============= */
const scaled = p=>({x:p.x*state.scale, y:p.y*state.scale, pres:p.pres});
function drawLine(ctx,a,b,opt){ const pressure=b.pres??1, base=opt.size||state.size; const w=opt.pressure? base*pressure: base; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle=opt.color||state.color; ctx.lineWidth=w; ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); }
function eraseLine(ctx,a,b,esize){ ctx.save(); ctx.globalCompositeOperation='destination-out'; drawLine(ctx,a,b,{color:'#000', size:esize||state.size*3, pressure:true}); ctx.restore(); }
function getLogicalPos(e){ const r=inkCanvas.getBoundingClientRect(); return {x:(e.clientX-r.left)/state.scale, y:(e.clientY-r.top)/state.scale, pres:e.pressure>0?e.pressure:1}; }
function begin(p){ state.drawing=true; state.last=p; state.stroke=[{p,tool:state.tool,color:state.color,size:state.size}]; }
function move(p){ if(!state.drawing) return; const a=state.last,b=p, As=scaled(a), Bs=scaled(b); if(state.tool==='pen') drawLine(inkCtx,As,Bs,{pressure:true,size:state.size*state.scale,color:state.color}); else eraseLine(inkCtx,As,Bs,(state.size*3)*state.scale); state.stroke.push({p,tool:state.tool,color:state.color,size:state.size}); state.last=b; }
function end(){ if(!state.drawing) return; state.drawing=false; state.history.push({ops:state.stroke, page: state.pdf?state.page:1}); state.redoStack=[]; scheduleNoteSave(); }
function redrawInk(){
  inkCtx.setTransform(dpr,0,0,dpr,0,0);
  inkCtx.clearRect(0,0,inkCanvas.width/dpr,inkCanvas.height/dpr);
  const curr = String(state.pdf?state.page:1);
  for(const h of state.history){
    if(String(h.page||1)!==curr) continue;
    for(let i=1;i<h.ops.length;i++){
      const A=h.ops[i-1],B=h.ops[i]; const a=scaled(A.p), b=scaled(B.p);
      if(B.tool==='pen') drawLine(inkCtx,a,b,{color:A.color,size:(A.size||state.size)*state.scale});
      else eraseLine(inkCtx,a,b,((A.size||state.size)*3)*state.scale);
    }
  }
}

/* ============= テキスト ============= */
function layoutTextboxes(){
  const curr=String(state.pdf?state.page:1);
  for(const t of state.texts){
    const onThisPage = String(t.page||1)===curr;
    t.el.style.display = onThisPage ? 'block' : 'none';
    if(!onThisPage) continue;
    t.el.style.left=(t.x*state.scale)+'px';
    t.el.style.top =(t.y*state.scale)+'px';
    t.el.style.fontSize=(t.fontSize*state.scale)+'px';
    t.el.style.color=t.color;
  }
}
function createTextbox(xCss,yCss,opts={}){
  const lx=xCss/state.scale, ly=yCss/state.scale;
  const el=document.createElement('div'); el.className='textbox sel'; el.contentEditable='true'; el.spellcheck=false;
  const color=toHexColor(opts.color||state.color); const fontSize=(opts.fontSize||+ui.fontSize.value);
  const pageIndex = state.pdf?state.page:1;
  const item={el,x:lx,y:ly,fontSize,color,page:pageIndex}; state.texts.push(item);
  el.style.left=(lx*state.scale)+'px'; el.style.top=(ly*state.scale)+'px';
  el.style.fontSize=(fontSize*state.scale)+'px'; el.style.color=color;
  el.dataset.color=color; el.dataset.fontSize=String(fontSize); el.dataset.page=String(pageIndex);
  el.addEventListener('focus',()=>selectTextbox(item));
  el.addEventListener('blur',()=>{ el.classList.remove('sel'); scheduleNoteSave(); });
  el.addEventListener('input',()=> scheduleNoteSave());
  el.addEventListener('keydown',(e)=>{ if((e.key==='Backspace'||e.key==='Delete') && el.textContent===''){ e.preventDefault(); removeTextbox(item); scheduleNoteSave(); } });
  let dragging=false,sx=0,sy=0;
  el.addEventListener('pointerdown',(e)=>{ dragging=true; el.setPointerCapture(e.pointerId); sx=e.clientX; sy=e.clientY; selectTextbox(item); });
  el.addEventListener('pointermove',(e)=>{ if(!dragging) return; const dx=e.clientX-sx, dy=e.clientY-sy; item.x+=dx/state.scale; item.y+=dy/state.scale; el.style.left=(item.x*state.scale)+'px'; el.style.top=(item.y*state.scale)+'px'; sx=e.clientX; sy=e.clientY; });
  ['pointerup','pointercancel','pointerleave','pointerout'].forEach(t=> el.addEventListener(t, ()=> dragging=false ));
  textLayer.appendChild(el);
  if(opts.focus!==false) el.focus(); else el.classList.remove('sel');
  layoutTextboxes(); return item;
}
function selectTextbox(item){ document.querySelectorAll('.textbox.sel').forEach(n=>n.classList.remove('sel')); item.el.classList.add('sel'); ui.color.value=item.color; setSelectedPalette(item.color); ui.fontSize.value=String(item.fontSize); }
function removeTextbox(item){ const i=state.texts.indexOf(item); if(i>=0) state.texts.splice(i,1); item.el.remove(); }

/* ============= UI events ============= */
ui.color.addEventListener('input', ()=> setSelectedPalette(ui.color.value));
ui.paletteWrap.addEventListener('click',(e)=>{ const b=e.target.closest('button[data-color]'); if(!b) return; setSelectedPalette(b.dataset.color); });
ui.size.addEventListener('input', ()=> state.size=+ui.size.value);
ui.fontSize.addEventListener('input', ()=>{ const sel=document.querySelector('.textbox.sel'); if(!sel) return; const item=state.texts.find(t=>t.el===sel); if(!item) return; item.fontSize=+ui.fontSize.value; layoutTextboxes(); scheduleNoteSave(); });
ui.penBtn.onclick=()=>setActiveTool('pen');
ui.eraserBtn.onclick=()=>setActiveTool('eraser');
ui.textBtn.onclick=()=>setActiveTool('text');
ui.handBtn.onclick=()=>setActiveTool('hand');
ui.undoBtn.onclick=()=>{ if(state.history.length){ state.redoStack.push(state.history.pop()); redrawInk(); scheduleNoteSave(); } };
ui.redoBtn.onclick=()=>{ if(state.redoStack.length){ state.history.push(state.redoStack.pop()); redrawInk(); scheduleNoteSave(); } };
ui.clearBtn.onclick=()=>{ if(confirm('全消去しますか？')){ state.history=[]; state.redoStack=[]; inkCtx.setTransform(dpr,0,0,dpr,0,0); inkCtx.clearRect(0,0,inkCanvas.width/dpr,inkCanvas.height/dpr); for(const t of state.texts)t.el.remove(); state.texts=[]; scheduleNoteSave(); } };
ui.pdfInput.onchange=async e=>{
  const f=e.target.files?.[0]; if(!f) return;
  try{
    const buf=await f.arrayBuffer();
    state.pdf=await pdfjsLib.getDocument({data:buf}).promise;
    state.totalPages=state.pdf.numPages; state.page=1;
    state.currentPdfUrl=null; // ローカル読み込みなので共有URLは未設定
    await drawPage();
  }catch(err){ console.error(err); alert('PDF読み込み失敗: '+(err.message||err)); }
};
ui.prev.onclick=()=>{ if(state.pdf && state.page>1){ state.page--; drawPage(); } };
ui.next.onclick=()=>{ if(state.pdf && state.page<state.totalPages){ state.page++; drawPage(); } };

/* ============= テキスト作成 ============= */
textLayer.addEventListener('pointerdown',(e)=>{
  if(state.tool!=='text') return;
  const r=textLayer.getBoundingClientRect();
  createTextbox(e.clientX-r.left, e.clientY-r.top, {fontSize:+ui.fontSize.value, color:state.color});
});

/* ============= 手ツール：スクロール ============= */
function canHandPanPointer(e){ if(state.isPinching) return false; if(state.tool!=='hand') return false; return true; }
stageWrap.addEventListener('pointerdown', e=>{ if(!canHandPanPointer(e)) return; state.isHandPanning = true; stageWrap.classList.add('grabbing'); state.handStart = { x:e.clientX, y:e.clientY, sl:stageWrap.scrollLeft, st:stageWrap.scrollTop }; try{ stageWrap.setPointerCapture(e.pointerId); }catch{} });
stageWrap.addEventListener('pointermove', e=>{ if(!state.isHandPanning) return; const dx = e.clientX - state.handStart.x; const dy = e.clientY - state.handStart.y; stageWrap.scrollLeft = state.handStart.sl - dx; stageWrap.scrollTop  = state.handStart.st - dy; });
['pointerup','pointercancel','pointerleave','pointerout'].forEach(t=>{ stageWrap.addEventListener(t, ()=>{ if(state.isHandPanning){ state.isHandPanning=false; stageWrap.classList.remove('grabbing'); } }); });

/* ============= Ink 入力（ペンのみ強化） ============= */
function isPenLike(e){ const isPen = e.pointerType === 'pen'; const isMouseOnNonTouchPC = (e.pointerType === 'mouse' && (navigator.maxTouchPoints||0) === 0); return isPen || isMouseOnNonTouchPC; }
inkCanvas.addEventListener('pointerdown', e => { if (state.isPinching) return; if (state.tool !== 'pen' && state.tool !== 'eraser') return; if (state.penOnly && !isPenLike(e)) return; if (state.activePointerId !== null && state.activePointerId !== e.pointerId) return; state.activePointerId = e.pointerId; state.activePointerType = e.pointerType; try { inkCanvas.setPointerCapture(e.pointerId); } catch {} begin(getLogicalPos(e)); });
inkCanvas.addEventListener('pointermove', e => { if (state.isPinching) return; if (state.activePointerId === null || e.pointerId !== state.activePointerId) return; if (state.tool !== 'pen' && state.tool !== 'eraser') return; if (state.penOnly && !isPenLike(e)) return; if (state.drawing) move(getLogicalPos(e)); });
function finishPointer(e){ if (state.activePointerId !== null && e.pointerId === state.activePointerId){ end(); state.activePointerId=null; state.activePointerType=null; } }
['pointerup','pointercancel','pointerout','pointerleave'].forEach(t=> inkCanvas.addEventListener(t, finishPointer));
ui.penOnly.addEventListener('change', e=>{ state.penOnly = e.target.checked; if (state.penOnly && state.activePointerType !== 'pen') { state.activePointerId=null; state.activePointerType=null; state.drawing=false; } });

/* ============= ピンチズーム & 2本指パン ============= */
function pointerPos(e){ return {x:e.clientX, y:e.clientY}; }
function onTouchPointersChanged(){ const touches=[...state.touches.values()]; if(touches.length>=2){ state.isPinching=true; const [a,b]=touches; const dx=b.x-a.x, dy=b.y-a.y; state.lastDist=Math.hypot(dx,dy); state.lastCenter={x:(a.x+b.x)/2, y:(a.y+b.y)/2}; } else { state.isPinching=false; } }
stageWrap.addEventListener('pointerdown', e=>{ if(e.pointerType==='touch'){ state.touches.set(e.pointerId, pointerPos(e)); onTouchPointersChanged(); } });
stageWrap.addEventListener('pointermove', e=>{ if(e.pointerType==='touch' && state.touches.has(e.pointerId)){ state.touches.set(e.pointerId, pointerPos(e)); if(state.touches.size>=2){ const t=[...state.touches.values()]; const [a,b]=t; const dx=b.x-a.x, dy=b.y-a.y; const newDist=Math.hypot(dx,dy); const center={x:(a.x+b.x)/2, y:(a.y+b.y)/2}; const delta=newDist/(state.lastDist||newDist); const rect=stageWrap.getBoundingClientRect(); const cx = center.x - rect.left + stageWrap.scrollLeft; const cy = center.y - rect.top  + stageWrap.scrollTop; if(delta>1.01 || delta<0.99){ const oldScale=state.scale; const newScale=Math.min(3, Math.max(0.5, oldScale*delta)); if(newScale!==oldScale){ state.scale=newScale; scheduleDrawThrottle(); const factor=newScale/oldScale; stageWrap.scrollLeft = Math.max(0, cx*factor - (center.x - rect.left)); stageWrap.scrollTop  = Math.max(0, cy*factor - (center.y - rect.top)); } }else{ const dxCenter = center.x - (state.lastCenter?.x ?? center.x); const dyCenter = center.y - (state.lastCenter?.y ?? center.y); stageWrap.scrollLeft -= dxCenter; stageWrap.scrollTop  -= dyCenter; } state.lastDist=newDist; state.lastCenter=center; e.preventDefault(); } } });
['pointerup','pointercancel','pointerleave','pointerout'].forEach(type=>{ stageWrap.addEventListener(type, e=>{ if(e.pointerType==='touch'){ state.touches.delete(e.pointerId); onTouchPointersChanged(); } }); });
let lastTap=0; stageWrap.addEventListener('pointerdown', e=>{ if(e.pointerType==='touch' && !state.isPinching){ const now=Date.now(); if(now-lastTap<300){ state.scale=1; drawPage().then(()=> stageWrap.scrollTo({left:0,top:0,behavior:'auto'})); } lastTap=now; } });

/* ============= PNG保存（見た目合成） ============= */
function savePNG(){
  const out=document.createElement('canvas'); out.width=pdfCanvas.width; out.height=pdfCanvas.height;
  const o=out.getContext('2d'); o.drawImage(pdfCanvas,0,0); o.drawImage(inkCanvas,0,0);
  const curr=String(state.pdf?state.page:1); o.textBaseline='top';
  for(const t of state.texts){
    if(String(t.page||1)!==curr) continue;
    const x=t.x*state.scale*dpr, y=t.y*state.scale*dpr, fontPx=Math.round(t.fontSize*state.scale*dpr);
    o.fillStyle=t.color;
    o.font=`${fontPx}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP",sans-serif`;
    const lines=(t.el.innerText||'').replace(/\r/g,'').split('\n');
    const lh=Math.round(t.fontSize*1.3*state.scale*dpr);
    for(let i=0;i<lines.length;i++){ o.fillText(lines[i], x, y+i*lh); }
  }
  const a=document.createElement('a'); a.href=out.toDataURL('image/png'); a.download=`note_page${state.pdf?state.page:1}.png`; a.click();
}
ui.savePNGBtn.onclick=savePNG;

/* ============= ノート保存/復元 ============= */
let saveTimer=null;
function scheduleNoteSave(){ clearTimeout(saveTimer); saveTimer=setTimeout(saveNoteNow, 1000); }
async function saveNoteNow(){
  const key = localStorage.getItem('APP_KEY') || prompt(APP_KEY_PROMPT) || '';
  if(!key) return; localStorage.setItem('APP_KEY', key);
  const snap = makeNoteSnapshot();
  try{
    const r = await fetch(`${SAVE_ENDPOINT}?op=note`, {
      method:'POST',
      headers:{
        'Content-Type':'application/json',
        'X-App-Key': key,
        'X-Op':'note',
        'X-Teacher': teacherId,
        'X-Aid': assignmentId,
        'X-Student': studentId
      },
      body: JSON.stringify(snap)
    });
    if(!r.ok){ console.warn('save failed', r.status, await r.text()); }
  }catch(e){ console.warn('save error', e); }
}
function makeNoteSnapshot(){
  const strokes = state.history.map(h=>({
    page: h.page || 1,
    tool: h.ops[0]?.tool || 'pen',
    color: h.ops[0]?.color || state.color,
    size:  h.ops[0]?.size  || state.size,
    points: h.ops.map(o=>[o.p.x, o.p.y, o.p.pres ?? 1])
  }));
  const texts = state.texts.map(t=>({
    page: t.page || Number(t.el.dataset.page||1),
    x: t.x, y: t.y, fontSize: t.fontSize, color: t.color,
    text: t.el.innerText || ''
  }));
  return { noteV:1, strokes, texts };
}
function applyNoteSnapshot(snap){
  state.history = [];
  for(const s of (snap.strokes||[])){
    const ops = s.points.map(p=>({ p:{x:p[0], y:p[1], pres:p[2]??1}, tool:s.tool, color:s.color, size:s.size }));
    state.history.push({ ops, page:s.page||1 });
  }
  redrawInk();
  for(const t of [...state.texts]) t.el.remove();
  state.texts=[];
  for(const t of (snap.texts||[])){
    const item = createTextbox(t.x*state.scale, t.y*state.scale, {fontSize:t.fontSize, color:t.color, focus:false});
    item.x=t.x; item.y=t.y; item.fontSize=t.fontSize; item.color=t.color;
    item.page = t.page||1; item.el.dataset.page=String(item.page);
    item.el.textContent = t.text||'';
  }
  layoutTextboxes();
}
async function loadNoteIfAny(){
  const key = localStorage.getItem('APP_KEY') || prompt(APP_KEY_PROMPT) || '';
  if(!key) return; localStorage.setItem('APP_KEY', key);
  try{
    const u = new URL(SAVE_ENDPOINT);
    u.searchParams.set('op','note');
    u.searchParams.set('teacher', teacherId);
    u.searchParams.set('aid', assignmentId);
    u.searchParams.set('student', studentId);
    u.searchParams.set('key', key);
    const r = await fetch(u.toString(), { method:'GET' });
    if(!r.ok) return;
    const j = await r.json();
    if(j && j.ok && j.note) applyNoteSnapshot(j.note);
  }catch(e){ console.warn('load note err', e); }
}

/* ============= PDFのURL読み込み・共有 ============= */
function buildShareUrl(pdfUrl){
  const base = location.origin + location.pathname;
  const q = new URLSearchParams();
  q.set('pdf', pdfUrl);
  q.set('t', teacherId); q.set('a', assignmentId); q.set('s', studentId);
  return `${base}?${q.toString()}`;
}
async function copyText(t){ try{ await navigator.clipboard.writeText(t); alert('コピーしました！'); }catch{ prompt('この文字列をコピーしてください', t); } }

async function loadPdfFromUrl(url){
  try{
    const res = await fetch(url, {mode:'cors'});
    if(!res.ok) throw new Error('fetch fail');
    const buf = await res.arrayBuffer();
    state.pdf = await pdfjsLib.getDocument({data:buf}).promise;
    state.totalPages = state.pdf.numPages; state.page = 1;
    state.currentPdfUrl = url;
    // アドレスバーも更新（履歴は汚さない）
    const qs = new URLSearchParams(location.search);
    qs.set('pdf', url); qs.set('t', teacherId); qs.set('a', assignmentId); qs.set('s', studentId);
    history.replaceState(null,'', location.pathname + '?' + qs.toString());
    await drawPage();
  }catch(e){ alert('PDFの読み込みに失敗しました'); console.warn(e); }
}

ui.openPdfUrlBtn.onclick = async ()=>{
  const u = prompt('読み込むPDFのURL（raw.githubusercontent.com など）を入力');
  if(!u) return;
  await loadPdfFromUrl(u.trim());
};

ui.copyShareBtn.onclick = async ()=>{
  if(!state.currentPdfUrl){
    alert('共有リンクを作るには、PDFをURLから読み込むか、GitHubに公開してください。');
    return;
  }
  const link = buildShareUrl(state.currentPdfUrl);
  copyText(link);
};

/* ============= GitHub にPDF公開（Worker経由） ============= */
async function uploadPdfToGithub(file){
  if (file.size > 9.5 * 1024 * 1024) { alert('PDFが10MBを超えています'); return null; }
  const key = localStorage.getItem('APP_KEY') || prompt(APP_KEY_PROMPT) || '';
  if (!key) return null;
  localStorage.setItem('APP_KEY', key);
  try{
    const res = await fetch(UPLOAD_ENDPOINT, {
      method:'POST',
      headers:{
        'Content-Type':'application/pdf',
        'X-App-Key': key,
        'X-Filename': file.name || 'worksheet.pdf',
        'X-Teacher': teacherId,
        'X-Aid': assignmentId
      },
      body:file
    });
    const txt = await res.text();
    const data = JSON.parse(txt);
    if(!res.ok || !data.ok){ throw new Error(txt); }
    state.currentPdfUrl = data.raw_url || null;
    const share = state.currentPdfUrl ? buildShareUrl(state.currentPdfUrl) : '';
    alert('PDFを公開しました！\n' + (share ? '共有リンクをコピーします。' : ''));
    if(share) copyText(share);
    return data.raw_url || null;
  }catch(e){
    console.error('UPLOAD_ERROR', e);
    alert('アップロードに失敗: ' + String(e));
    return null;
  }
}
ui.uploadPdfBtn.onclick = ()=> ui.uploadPdfFile.click();
ui.uploadPdfFile.onchange = async e=>{
  const f=e.target.files?.[0];
  if(!f) return;
  await uploadPdfToGithub(f);
  e.target.value='';
};

/* ============= 起動時：?pdf= があれば自動読込 ============= */
async function tryAutoLoadPDF(){
  const q = new URLSearchParams(location.search);
  const url = q.get('pdf');
  if(!url) return;
  state.currentPdfUrl = url;
  await loadPdfFromUrl(url);
}

/* ============= 初期化 ============= */
window.addEventListener('load', async ()=>{
  await drawPage();
  await tryAutoLoadPDF();
  await loadNoteIfAny();
});
window.addEventListener('resize', ()=> drawPage() );
</script>
</body>
</html>
