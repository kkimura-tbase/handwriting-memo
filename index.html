<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>æ‰‹æ›¸ããƒ¡ãƒ¢ï¼ˆPDFãƒ»URLå…±æœ‰ãƒ»GitHubå…¬é–‹å¯¾å¿œï¼‰</title>
<link rel="icon" href="data:,">
<style>
  html,body{height:100%;margin:0;font-family:system-ui}
  .app{display:grid;grid-template-rows:auto 1fr;height:100%}
  .toolbar{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;
           padding:.6rem;background:#f6f6f6;border-bottom:1px solid #ddd}
  .toolbar>*{background:#fff;border:1px solid #ddd;border-radius:.5rem;padding:.3rem .6rem}
  #stageWrap{position:relative;height:100%;min-height:360px;background:#fff;overflow:auto;touch-action: pan-x pan-y;}
  canvas{position:absolute;inset:0;width:100%;height:100%;touch-action:none;display:block}
  #pdfLayer{z-index:0}
  #inkLayer{z-index:1}
  #textLayer{z-index:2;position:absolute;inset:0;pointer-events:none}
  .tool-btn{transition:.15s}
  .tool-btn.active{background:#e8f0fe;border-color:#6a9bff;box-shadow:0 0 0 2px #cfe0ff inset}
  .palette button{width:24px;height:24px;border-radius:50%;padding:0;border:2px solid #ccc;cursor:pointer}
  .palette button.sel{box-shadow:0 0 0 3px #444 inset;border-color:#222}
  .textbox{position:absolute;min-width:40px;min-height:24px;padding:2px 4px;outline:none;border:1px dashed transparent;
           white-space:pre-wrap;word-break:break-word;background:transparent;cursor:text;user-select:text}
  .textbox.sel{border-color:#6a9bff;box-shadow:0 0 0 2px #cfe0ff inset;background:rgba(255,255,255,.2)}
  .grabbing{cursor:grabbing;}
</style>
</head>
<body>
<div class="app">
  <div class="toolbar">
    <label>å¤ªã• <input id="size" type="range" min="1" max="30" value="4"></label>
    <label>è‰² <input id="color" type="color" value="#111111"></label>
    <div class="palette" id="palette">
      <button data-color="#000000" style="background:#000000"></button>
      <button data-color="#ff0000" style="background:#ff0000"></button>
      <button data-color="#0000ff" style="background:#0000ff"></button>
      <button data-color="#008000" style="background:#008000"></button>
      <button data-color="#ffa500" style="background:#ffa500"></button>
      <button data-color="#ffff00" style="background:#ffff00"></button>
    </div>
    <button id="penBtn" class="tool-btn" aria-pressed="true">âœ’ï¸ãƒšãƒ³</button>
    <button id="eraserBtn" class="tool-btn" aria-pressed="false">ğŸ§½æ¶ˆã—ã‚´ãƒ </button>
    <button id="textBtn" class="tool-btn" aria-pressed="false">T ãƒ†ã‚­ã‚¹ãƒˆ</button>
    <button id="handBtn" class="tool-btn" aria-pressed="false">âœ‹ç§»å‹•</button>
    <label>æ–‡å­— <input id="fontSize" type="number" min="10" max="96" value="18" style="width:4.5rem"></label>
    <label><input type="checkbox" id="penOnly">ãƒšãƒ³ã®ã¿</label>
    <button id="undoBtn">â†¶Undo</button>
    <button id="redoBtn">â†·Redo</button>
    <button id="clearBtn">ğŸ—‘ å…¨æ¶ˆå»</button>

    <input type="file" id="pdfInput" accept="application/pdf">
    <button id="prevPage">â—€</button><span id="pageInfo">-/-</span><button id="nextPage">â–¶</button>
    <button id="scrollUp">â–²</button><button id="scrollDown">â–¼</button>
    <button id="savePNGBtn">PNGä¿å­˜</button>

    <!-- URLå…±æœ‰ -->
    <button id="shareLinkBtn">ğŸ”— å…±æœ‰ãƒªãƒ³ã‚¯ã‚’ä½œæˆ</button>
    <button id="openLinkBtn">ğŸ”— å…±æœ‰ãƒªãƒ³ã‚¯ã‚’èª­è¾¼</button>

    <!-- GitHubå…¬é–‹ï¼ˆCloudflare Worker çµŒç”±ï¼‰ -->
    <button id="uploadPdfBtn">ğŸ“¤ PDFã‚’å…¬é–‹ï¼ˆGitHubä¿å­˜ï¼‰</button>
  </div>

  <div id="stageWrap">
    <canvas id="pdfLayer"></canvas>
    <canvas id="inkLayer"></canvas>
    <div id="textLayer"></div>
  </div>
</div>

<script type="module">
/* ===== ä¾å­˜èª­ã¿è¾¼ã¿ ===== */
import * as pdfjsLib from './build/pdf.mjs';
pdfjsLib.GlobalWorkerOptions.workerSrc = './build/pdf.worker.mjs';
import pako from 'https://esm.sh/pako@2.1.0';

/* ===== ã‚ãªãŸã®Cloudflare Workerï¼ˆPDFå…¬é–‹å…ˆï¼‰ ===== */
const UPLOAD_ENDPOINT = "https://pdf-uploader-plain-union-c1fe.kkimura.workers.dev";
const APP_KEY_PROMPT  = "å…ˆç”Ÿç”¨ã‚­ãƒ¼ï¼ˆåˆè¨€è‘‰ï¼‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„";

/* ====== åŸºæœ¬ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ====== */
const dpr = window.devicePixelRatio||1;
const pdfCanvas = document.getElementById('pdfLayer');
const inkCanvas = document.getElementById('inkLayer');
const textLayer = document.getElementById('textLayer');
const pdfCtx = pdfCanvas.getContext('2d');
const inkCtx = inkCanvas.getContext('2d');
const stageWrap = document.getElementById('stageWrap');

const ui = {
  size:document.getElementById('size'),
  color:document.getElementById('color'),
  fontSize:document.getElementById('fontSize'),
  penBtn:document.getElementById('penBtn'),
  eraserBtn:document.getElementById('eraserBtn'),
  textBtn:document.getElementById('textBtn'),
  handBtn:document.getElementById('handBtn'),
  penOnly:document.getElementById('penOnly'),
  undoBtn:document.getElementById('undoBtn'),
  redoBtn:document.getElementById('redoBtn'),
  clearBtn:document.getElementById('clearBtn'),
  pdfInput:document.getElementById('pdfInput'),
  prev:document.getElementById('prevPage'),
  next:document.getElementById('nextPage'),
  info:document.getElementById('pageInfo'),
  savePNGBtn:document.getElementById('savePNGBtn'),
  paletteWrap:document.getElementById('palette'),
  paletteBtns:document.querySelectorAll('#palette button'),
  scrollUp:document.getElementById('scrollUp'),
  scrollDown:document.getElementById('scrollDown'),
  shareBtn:document.getElementById('shareLinkBtn'),
  openShareBtn:document.getElementById('openLinkBtn'),
  uploadPdfBtn:document.getElementById('uploadPdfBtn'),
};

function toHexColor(c){
  if(!c) return '#111111';
  c=String(c).trim().toLowerCase();
  if(c.startsWith('#')){ if(c.length===4){const r=c[1],g=c[2],b=c[3]; return `#${r}${r}${g}${g}${b}${b}`;} return c.slice(0,7); }
  const m=c.match(/rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
  if(m){ const to2=n=>Math.max(0,Math.min(255,parseInt(n,10))).toString(16).padStart(2,'0'); return `#${to2(m[1])}${to2(m[2])}${to2(m[3])}`; }
  const NAME={black:'#000000',white:'#ffffff',red:'#ff0000',blue:'#0000ff',green:'#008000',yellow:'#ffff00',orange:'#ffa500',gray:'#808080',grey:'#808080'};
  return NAME[c]||'#111111';
}

const state = {
  tool:'pen', color:toHexColor(ui.color.value), size:+ui.size.value,
  drawing:false, last:null, stroke:[], history:[], redoStack:[],
  pdf:null, page:1, totalPages:0,
  scale:1, baseWidth:0, baseHeight:0,
  margin:200, pdfOffsetX:0, pdfOffsetY:0,
  texts:[],
  isPinching:false, touches:new Map(), lastCenter:null, lastDist:0, rafScheduled:false,
  isHandPanning:false, handStart: {x:0,y:0,sl:0,st:0},
  renderTask:null, renderSeq:0,
  activePointerId:null, activePointerType:null,
  penOnly:false,
};

/* ===== ãƒ„ãƒ¼ãƒ«åˆ‡æ›¿ ===== */
function setActiveTool(tool){
  state.tool=tool;
  const map={pen:ui.penBtn,eraser:ui.eraserBtn,text:ui.textBtn,hand:ui.handBtn};
  [ui.penBtn,ui.eraserBtn,ui.textBtn,ui.handBtn].forEach(b=>{
    const on=b===map[tool]; b.classList.toggle('active',on); b.setAttribute('aria-pressed',String(on));
  });
  textLayer.style.pointerEvents = (tool==='text')?'auto':'none';
  stageWrap.classList.toggle('grabbing', tool==='hand' && state.isHandPanning);
}
setActiveTool('pen');

function setSelectedPalette(color){
  const hex=toHexColor(color);
  state.color=hex; ui.color.value=hex;
  for(const b of ui.paletteBtns){ b.classList.toggle('sel', b.dataset.color?.toLowerCase()===hex.toLowerCase()); }
  const sel=document.querySelector('.textbox.sel'); if(sel){ sel.style.color=hex; sel.dataset.color=hex; }
}
setSelectedPalette(ui.color.value);

/* ===== ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ ===== */
function ensureBaseSize(){
  if(state.baseWidth && state.baseHeight) return;
  const cssW=Math.max(600, stageWrap.clientWidth||800);
  const cssH=Math.round(cssW*1.41421356);
  state.baseWidth=cssW; state.baseHeight=cssH;
}
function contentWidth(){ return state.baseWidth + state.margin*2; }
function contentHeight(){ return state.baseHeight + state.margin*2; }

/* ===== æç”» ===== */
async function drawPage(){
  ensureBaseSize();
  if(state.renderTask){ try{ state.renderTask.cancel(); }catch{} state.renderTask=null; }
  const seq = ++state.renderSeq;

  if(state.pdf){
    const page = await state.pdf.getPage(state.page);
    const v1 = page.getViewport({scale:1});
    state.baseWidth=v1.width; state.baseHeight=v1.height;
  }

  const W = contentWidth()*state.scale, H = contentHeight()*state.scale;
  pdfCanvas.width=Math.round(W*dpr); pdfCanvas.height=Math.round(H*dpr);
  inkCanvas.width=pdfCanvas.width;   inkCanvas.height=pdfCanvas.height;
  pdfCanvas.style.width=W+'px'; pdfCanvas.style.height=H+'px';
  inkCanvas.style.width=W+'px';   inkCanvas.style.height=H+'px';
  textLayer.style.width=W+'px';   textLayer.style.height=H+'px';

  pdfCtx.setTransform(dpr,0,0,dpr,0,0);
  pdfCtx.fillStyle='#ffffff';
  pdfCtx.fillRect(0,0,pdfCanvas.width/dpr,pdfCanvas.height/dpr);
  pdfCtx.strokeStyle='#e0e0e0'; pdfCtx.lineWidth=1;
  pdfCtx.strokeRect(0.5,0.5,(pdfCanvas.width/dpr)-1,(pdfCanvas.height/dpr)-1);

  if(state.pdf){
    const page = await state.pdf.getPage(state.page);
    const v = page.getViewport({scale:state.scale});
    const offsetX = state.margin*state.scale;
    const offsetY = state.margin*state.scale;
    state.pdfOffsetX = state.margin; state.pdfOffsetY = state.margin;

    pdfCtx.save();
    pdfCtx.translate(offsetX, offsetY);
    try{
      const task = page.render({canvasContext:pdfCtx, viewport:v});
      state.renderTask = task;
      await task.promise;
      if(seq!==state.renderSeq) return;
    }catch(e){} finally{ if(seq===state.renderSeq) state.renderTask=null; pdfCtx.restore(); }
    ui.info.textContent=`${state.page}/${state.totalPages}`;
  }else{
    ui.info.textContent='â€”/â€”';
  }
  redrawInk();
  layoutTextboxes();
}
function scheduleDrawThrottle(){
  if(state.rafScheduled) return;
  state.rafScheduled=true;
  requestAnimationFrame(()=>{ state.rafScheduled=false; drawPage(); });
}

/* ===== Ink ===== */
const scaled = p=>({x:p.x*state.scale, y:p.y*state.scale, pres:p.pres});
function drawLine(ctx,a,b,opt){
  const pressure=b.pres??1, base=opt.size||state.size;
  const w=opt.pressure? base*pressure: base;
  ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle=opt.color||state.color; ctx.lineWidth=w;
  ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
}
function eraseLine(ctx,a,b,esize){
  ctx.save(); ctx.globalCompositeOperation='destination-out';
  drawLine(ctx,a,b,{color:'#000', size:esize||state.size*4, pressure:true}); // â† æ¶ˆã—ã‚´ãƒ ã¯ãƒšãƒ³ã®ç´„4å€
  ctx.restore();
}
function getLogicalPos(e){
  const r=inkCanvas.getBoundingClientRect();
  return {x:(e.clientX-r.left)/state.scale, y:(e.clientY-r.top)/state.scale, pres:e.pressure>0?e.pressure:1};
}
function begin(p){ state.drawing=true; state.last=p; state.stroke=[{p,tool:state.tool,color:state.color,size:state.size}]; }
function move(p){
  if(!state.drawing) return;
  const a=state.last,b=p, As=scaled(a), Bs=scaled(b);
  if(state.tool==='pen') drawLine(inkCtx,As,Bs,{pressure:true,size:state.size*state.scale,color:state.color});
  else eraseLine(inkCtx,As,Bs,(state.size*4)*state.scale);
  state.stroke.push({p,tool:state.tool,color:state.color,size:state.size});
  state.last=b;
}
function end(){ if(!state.drawing) return; state.drawing=false; state.history.push({ops:state.stroke}); state.redoStack=[]; }
function redrawInk(){
  inkCtx.setTransform(dpr,0,0,dpr,0,0);
  inkCtx.clearRect(0,0,inkCanvas.width/dpr,inkCanvas.height/dpr);
  for(const h of state.history){
    for(let i=1;i<h.ops.length;i++){
      const A=h.ops[i-1],B=h.ops[i]; const a=scaled(A.p), b=scaled(B.p);
      if(B.tool==='pen') drawLine(inkCtx,a,b,{color:A.color,size:(A.size||state.size)*state.scale});
      else eraseLine(inkCtx,a,b,((A.size||state.size)*4)*state.scale);
    }
  }
}

/* ===== ãƒ†ã‚­ã‚¹ãƒˆ ===== */
function layoutTextboxes(){
  const curr=String(state.pdf?state.page:1);
  for(const t of state.texts){
    const {el,page,fontSize,color,x,y}=t;
    const onThisPage = String(page||1)===curr;
    el.style.display = onThisPage ? 'block' : 'none';
    if(!onThisPage) continue;
    el.style.left=(x*state.scale)+'px';
    el.style.top =(y*state.scale)+'px';
    el.style.fontSize=(fontSize*state.scale)+'px';
    el.style.color=color;
  }
}
function createTextbox(xCss,yCss,opts={}){
  const lx=xCss/state.scale, ly=yCss/state.scale;
  const el=document.createElement('div'); el.className='textbox sel'; el.contentEditable='true'; el.spellcheck=false;
  const color=toHexColor(opts.color||state.color); const fontSize=(opts.fontSize||+ui.fontSize.value);
  const pageIndex = state.pdf?state.page:1;
  const item={el,x:lx,y:ly,fontSize,color,page:pageIndex}; state.texts.push(item);
  el.style.left=(lx*state.scale)+'px'; el.style.top=(ly*state.scale)+'px';
  el.style.fontSize=(fontSize*state.scale)+'px'; el.style.color=color;
  el.dataset.color=color; el.dataset.fontSize=String(fontSize); el.dataset.page=String(pageIndex);
  el.addEventListener('focus',()=>selectTextbox(item));
  el.addEventListener('blur',()=>el.classList.remove('sel'));
  el.addEventListener('keydown',(e)=>{ if((e.key==='Backspace'||e.key==='Delete') && el.textContent===''){ e.preventDefault(); removeTextbox(item);} });
  let dragging=false,sx=0,sy=0;
  el.addEventListener('pointerdown',(e)=>{ dragging=true; el.setPointerCapture(e.pointerId); sx=e.clientX; sy=e.clientY; selectTextbox(item); });
  el.addEventListener('pointermove',(e)=>{ if(!dragging) return; const dx=e.clientX-sx, dy=e.clientY-sy; item.x+=dx/state.scale; item.y+=dy/state.scale; el.style.left=(item.x*state.scale)+'px'; el.style.top=(item.y*state.scale)+'px'; sx=e.clientX; sy=e.clientY; });
  ['pointerup','pointercancel','pointerleave','pointerout'].forEach(t=> el.addEventListener(t, ()=> dragging=false ));
  textLayer.appendChild(el); el.focus(); layoutTextboxes(); return item;
}
function selectTextbox(item){
  document.querySelectorAll('.textbox.sel').forEach(n=>n.classList.remove('sel'));
  item.el.classList.add('sel');
  ui.color.value=item.color; setSelectedPalette(item.color); ui.fontSize.value=String(item.fontSize);
}
function removeTextbox(item){ const i=state.texts.indexOf(item); if(i>=0) state.texts.splice(i,1); item.el.remove(); }

function exportTextsToJSON(){
  return state.texts.map(t=>({
    x:t.x,y:t.y,fontSize:t.fontSize,color:t.color,page:t.page,
    text: t.el.innerText || ''
  }));
}
function restoreTextboxesFromJSON(arr){
  // æ—¢å­˜å‰Šé™¤
  for(const t of state.texts){ t.el.remove(); }
  state.texts=[];
  if(!Array.isArray(arr)) return;
  for(const t of arr){
    const item=createTextbox((t.x||0)*state.scale,(t.y||0)*state.scale,{fontSize:+t.fontSize||18,color:t.color||'#111'});
    item.x=+t.x||0; item.y=+t.y||0; item.fontSize=+t.fontSize||18; item.color=t.color||'#111'; item.page=+t.page||1;
    item.el.innerText = t.text||'';
    item.el.dataset.page=String(item.page);
    item.el.classList.remove('sel');
  }
  layoutTextboxes();
}

/* ===== UI events ===== */
ui.color.addEventListener('input', ()=> setSelectedPalette(ui.color.value));
ui.paletteWrap.addEventListener('click',(e)=>{ const b=e.target.closest('button[data-color]'); if(!b) return; setSelectedPalette(b.dataset.color); });
ui.size.addEventListener('input', ()=> state.size=+ui.size.value);
ui.fontSize.addEventListener('input', ()=>{ const sel=document.querySelector('.textbox.sel'); if(!sel) return; const item=state.texts.find(t=>t.el===sel); if(!item) return; item.fontSize=+ui.fontSize.value; layoutTextboxes(); });
ui.penBtn.onclick=()=>setActiveTool('pen');
ui.eraserBtn.onclick=()=>setActiveTool('eraser');
ui.textBtn.onclick=()=>setActiveTool('text');
ui.handBtn.onclick=()=>setActiveTool('hand');
ui.undoBtn.onclick=()=>{ if(state.history.length){ state.redoStack.push(state.history.pop()); redrawInk(); } };
ui.redoBtn.onclick=()=>{ if(state.redoStack.length){ state.history.push(state.redoStack.pop()); redrawInk(); } };
ui.clearBtn.onclick=()=>{ if(confirm('å…¨æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ')){ state.history=[]; state.redoStack=[]; inkCtx.setTransform(dpr,0,0,dpr,0,0); inkCtx.clearRect(0,0,inkCanvas.width/dpr,inkCanvas.height/dpr); for(const t of state.texts)t.el.remove(); state.texts=[]; } };
ui.pdfInput.onchange=async e=>{
  const f=e.target.files?.[0]; if(!f) return;
  try{
    const buf=await f.arrayBuffer();
    state.pdf=await pdfjsLib.getDocument({data:buf}).promise;
    state.totalPages=state.pdf.numPages; state.page=1;
    await drawPage();
  }catch(err){ console.error(err); alert('PDFèª­ã¿è¾¼ã¿å¤±æ•—: '+(err.message||err)); }
};
ui.prev.onclick=()=>{ if(state.pdf && state.page>1){ state.page--; drawPage(); } };
ui.next.onclick=()=>{ if(state.pdf && state.page<state.totalPages){ state.page++; drawPage(); } };
ui.scrollUp.onclick=()=>stageWrap.scrollBy({top:-200,behavior:'smooth'});
ui.scrollDown.onclick=()=>stageWrap.scrollBy({top:200,behavior:'smooth'});

/* ãƒ†ã‚­ã‚¹ãƒˆä½œæˆ */
textLayer.addEventListener('pointerdown',(e)=>{
  if(state.tool!=='text') return;
  const r=textLayer.getBoundingClientRect();
  createTextbox(e.clientX-r.left, e.clientY-r.top, {fontSize:+ui.fontSize.value, color:state.color});
});

/* ===== æ‰‹ãƒ„ãƒ¼ãƒ«ï¼ˆ1æœ¬æŒ‡ï¼ãƒã‚¦ã‚¹ã§ãƒ‰ãƒ©ãƒƒã‚°ï¼ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼‰ ===== */
function canHandPanPointer(e){
  if(state.isPinching) return false;
  if(state.tool!=='hand') return false;
  return true;
}
stageWrap.addEventListener('pointerdown', e=>{
  if(!canHandPanPointer(e)) return;
  state.isHandPanning = true;
  stageWrap.classList.add('grabbing');
  state.handStart = { x:e.clientX, y:e.clientY, sl:stageWrap.scrollLeft, st:stageWrap.scrollTop };
  try{ stageWrap.setPointerCapture(e.pointerId); }catch{}
});
stageWrap.addEventListener('pointermove', e=>{
  if(!state.isHandPanning) return;
  const dx = e.clientX - state.handStart.x;
  const dy = e.clientY - state.handStart.y;
  stageWrap.scrollLeft = state.handStart.sl - dx;
  stageWrap.scrollTop  = state.handStart.st - dy;
});
['pointerup','pointercancel','pointerleave','pointerout'].forEach(t=>{
  stageWrap.addEventListener(t, ()=>{
    if(state.isHandPanning){
      state.isHandPanning=false;
      stageWrap.classList.remove('grabbing');
    }
  });
});

/* ===== Ink å…¥åŠ›ï¼ˆâ€œãƒšãƒ³ã®ã¿â€å¼·åŒ– & ãƒã‚¤ãƒ³ã‚¿æŒ‡åï¼‰ ===== */
function isPenLike(e){
  const isPen = e.pointerType === 'pen';
  const isMouseOnNonTouchPC = (e.pointerType === 'mouse' && (navigator.maxTouchPoints||0) === 0);
  return isPen || isMouseOnNonTouchPC;
}
inkCanvas.addEventListener('pointerdown', e => {
  if (state.isPinching) return;
  if (state.tool !== 'pen' && state.tool !== 'eraser') return;
  if (state.penOnly && !isPenLike(e)) return;
  if (state.activePointerId !== null && state.activePointerId !== e.pointerId) return;

  state.activePointerId = e.pointerId;
  state.activePointerType = e.pointerType;
  try { inkCanvas.setPointerCapture(e.pointerId); } catch {}
  begin(getLogicalPos(e));
});
inkCanvas.addEventListener('pointermove', e => {
  if (state.isPinching) return;
  if (state.activePointerId === null || e.pointerId !== state.activePointerId) return;
  if (state.tool !== 'pen' && state.tool !== 'eraser') return;
  if (state.penOnly && !isPenLike(e)) return;
  if (state.drawing) move(getLogicalPos(e));
});
function finishPointer(e){
  if (state.activePointerId !== null && e.pointerId === state.activePointerId){
    end(); state.activePointerId=null; state.activePointerType=null;
  }
}
['pointerup','pointercancel','pointerout','pointerleave'].forEach(t=> inkCanvas.addEventListener(t, finishPointer));
ui.penOnly.addEventListener('change', e=>{
  state.penOnly = e.target.checked;
  if (state.penOnly && state.activePointerType !== 'pen') {
    state.activePointerId=null; state.activePointerType=null; state.drawing=false;
  }
});

/* ===== ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ  & 2æœ¬æŒ‡ãƒ‘ãƒ³ ===== */
function pointerPos(e){ return {x:e.clientX, y:e.clientY}; }
function onTouchPointersChanged(){
  const touches=[...state.touches.values()];
  if(touches.length>=2){
    state.isPinching=true;
    const [a,b]=touches; const dx=b.x-a.x, dy=b.y-a.y;
    state.lastDist=Math.hypot(dx,dy);
    state.lastCenter={x:(a.x+b.x)/2, y:(a.y+b.y)/2};
  }else{
    state.isPinching=false;
  }
}
stageWrap.addEventListener('pointerdown', e=>{
  if(e.pointerType==='touch'){
    state.touches.set(e.pointerId, pointerPos(e));
    onTouchPointersChanged();
  }
});
stageWrap.addEventListener('pointermove', e=>{
  if(e.pointerType==='touch' && state.touches.has(e.pointerId)){
    state.touches.set(e.pointerId, pointerPos(e));
    if(state.touches.size>=2){
      const t=[...state.touches.values()];
      const [a,b]=t; const dx=b.x-a.x, dy=b.y-a.y;
      const newDist=Math.hypot(dx,dy);
      const center={x:(a.x+b.x)/2, y:(a.y+b.y)/2};
      const delta=newDist/(state.lastDist||newDist);

      const rect=stageWrap.getBoundingClientRect();
      const cx = center.x - rect.left + stageWrap.scrollLeft;
      const cy = center.y - rect.top  + stageWrap.scrollTop;

      if(delta>1.01 || delta<0.99){
        const oldScale=state.scale;
        const newScale=Math.min(3, Math.max(0.5, oldScale*delta));
        if(newScale!==oldScale){
          state.scale=newScale;
          scheduleDrawThrottle();
          const factor=newScale/oldScale;
          stageWrap.scrollLeft = Math.max(0, cx*factor - (center.x - rect.left));
          stageWrap.scrollTop  = Math.max(0, cy*factor - (center.y - rect.top));
        }
      }else{
        const dxCenter = center.x - (state.lastCenter?.x ?? center.x);
        const dyCenter = center.y - (state.lastCenter?.y ?? center.y);
        stageWrap.scrollLeft -= dxCenter;
        stageWrap.scrollTop  -= dyCenter;
      }

      state.lastDist=newDist; state.lastCenter=center;
      e.preventDefault();
    }
  }
});
['pointerup','pointercancel','pointerleave','pointerout'].forEach(type=>{
  stageWrap.addEventListener(type, e=>{
    if(e.pointerType==='touch'){
      state.touches.delete(e.pointerId);
      onTouchPointersChanged();
    }
  });
});
let lastTap=0;
stageWrap.addEventListener('pointerdown', e=>{
  if(e.pointerType==='touch' && !state.isPinching){
    const now=Date.now();
    if(now-lastTap<300){
      state.scale=1;
      drawPage().then(()=> stageWrap.scrollTo({left:0,top:0,behavior:'auto'}));
    }
    lastTap=now;
  }
});

/* ===== ä¿å­˜ï¼ˆPNGåˆæˆï¼‰ ===== */
function savePNG(){
  const out=document.createElement('canvas'); out.width=pdfCanvas.width; out.height=pdfCanvas.height;
  const o=out.getContext('2d'); o.drawImage(pdfCanvas,0,0); o.drawImage(inkCanvas,0,0);
  const curr=String(state.pdf?state.page:1); o.textBaseline='top';
  for(const t of state.texts){
    if(String(t.page||1)!==curr) continue;
    const x=t.x*state.scale*dpr, y=t.y*state.scale*dpr, fontPx=Math.round(t.fontSize*state.scale*dpr);
    o.fillStyle=t.color;
    o.font=`${fontPx}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP",sans-serif`;
    const lines=(t.el.innerText||'').replace(/\r/g,'').split('\n');
    const lh=Math.round(t.fontSize*1.3*state.scale*dpr);
    for(let i=0;i<lines.length;i++){ o.fillText(lines[i], x, y+i*lh); }
  }
  const a=document.createElement('a'); a.href=out.toDataURL('image/png'); a.download=`note_page${state.pdf?state.page:1}.png`; a.click();
}
ui.savePNGBtn.onclick=savePNG;

/* ====== PDFè‡ªå‹•èª­è¾¼ï¼ˆ?pdf / ?fileId / ?urlï¼‰ ====== */
function parseDriveFileIdFromAny(input) {
  if (!input) return null;
  const s = String(input).trim();
  if (/^[A-Za-z0-9_-]{20,}$/.test(s) && !s.includes('://')) return s;
  const q = s.match(/[?&]id=([A-Za-z0-9_-]+)/); if (q) return q[1];
  const d = s.match(/\/d\/([A-Za-z0-9_-]+)/);    if (d) return d[1];
  const tail = s.split(/[/?&=]/).reverse().find(tok => /^[A-Za-z0-9_-]{20,}$/.test(tok));
  return tail || null;
}
async function fetchPdfArrayBuffer({fileId, pdfUrl}){
  let url = null;
  if (fileId) url = `https://drive.google.com/uc?export=download&id=${encodeURIComponent(fileId)}`;
  else if (pdfUrl) url = pdfUrl;
  else throw new Error('no source');
  const res = await fetch(url); if(!res.ok) throw new Error('fetch failed');
  return await res.arrayBuffer();
}
async function autoLoadPdfFromQuery(){
  const sp = new URLSearchParams(location.search);
  let pdfUrl = sp.get('pdf');
  let fileId = sp.get('fileId');
  const urlParam = sp.get('url');

  if (!fileId && urlParam) {
    const id = parseDriveFileIdFromAny(urlParam);
    if (id) {
      fileId = id;
      sp.set('fileId', fileId);
      history.replaceState(null, '', location.pathname + '?' + sp.toString() + location.hash);
    }
  }
  if (!pdfUrl && !fileId) return false;

  try{
    const buf = await fetchPdfArrayBuffer({ fileId, pdfUrl });
    state.pdf = await pdfjsLib.getDocument({ data: buf }).promise;
    state.totalPages = state.pdf.numPages;
    state.page = 1;
    await drawPage();
    return true;
  }catch(err){
    console.error('AutoLoad failed:', err);
    alert('PDFã®è‡ªå‹•èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒªãƒ³ã‚¯ã‚’ã”ç¢ºèªãã ã•ã„ã€‚');
    return false;
  }
}

/* ===== URLå…±æœ‰ (#S=â€¦) ===== */
function bytesToBase64Url(uint8){
  let bin = ''; for(let i=0;i<uint8.length;i++) bin += String.fromCharCode(uint8[i]);
  return btoa(bin).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}
function base64UrlToBytes(s){
  s = s.replace(/-/g,'+').replace(/_/g,'/'); while(s.length%4) s+='=';
  const bin = atob(s); const out = new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) out[i] = bin.charCodeAt(i);
  return out;
}
function serializeStateForShare(){
  const sp = new URLSearchParams(location.search);
  const payload = {
    v:1,
    fileId: sp.get('fileId') || null,
    pdf:    sp.get('pdf')    || null,
    history: state.history,
    texts:   exportTextsToJSON(),
    scale:   state.scale,
    page:    state.page
  };
  return JSON.stringify(payload);
}
function buildShareLink(){
  const json = serializeStateForShare();
  const deflated = pako.deflate(json);
  const b64url   = bytesToBase64Url(deflated);
  const base = location.origin + location.pathname;
  const sp = new URLSearchParams(location.search);
  const keep = new URLSearchParams();
  if (sp.get('fileId')) keep.set('fileId', sp.get('fileId'));
  if (sp.get('pdf'))    keep.set('pdf',    sp.get('pdf'));
  const qs = keep.toString();
  return base + (qs ? ('?' + qs) : '') + '#S=' + b64url;
}
async function tryRestoreFromHash(){
  const m = (location.hash||'').match(/[#&]S=([^&]+)/);
  if(!m) return false;
  try{
    const buf = base64UrlToBytes(m[1]);
    const json = new TextDecoder().decode(pako.inflate(buf));
    const data = JSON.parse(json);

    if (data.fileId || data.pdf){
      const bufPdf = await fetchPdfArrayBuffer({ fileId: data.fileId, pdfUrl: data.pdf });
      state.pdf = await pdfjsLib.getDocument({ data: bufPdf }).promise;
      state.totalPages = state.pdf.numPages;
      state.page = Math.min(Math.max(1, data.page||1), state.totalPages);
    }

    state.history = Array.isArray(data.history) ? data.history : [];
    restoreTextboxesFromJSON(Array.isArray(data.texts)?data.texts:[]);
    state.scale = Number(data.scale || 1);

    await drawPage();
    return true;
  }catch(e){
    console.error(e);
    alert('å…±æœ‰ãƒªãƒ³ã‚¯ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
    return false;
  }
}
ui.shareBtn.addEventListener('click', ()=>{
  try{
    const url = buildShareLink();
    navigator.clipboard?.writeText(url);
    alert('å…±æœ‰ãƒªãƒ³ã‚¯ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼\n' + url);
  }catch(e){
    console.error(e);
    alert('å…±æœ‰ãƒªãƒ³ã‚¯ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
  }
});
ui.openShareBtn.addEventListener('click', async ()=>{
  const link = prompt('å…±æœ‰ãƒªãƒ³ã‚¯ï¼ˆ#S= ã‚’å«ã‚€URLï¼‰ã‚’è²¼ã£ã¦ãã ã•ã„:');
  if(!link) return;
  history.replaceState(null, '', link);
  await tryRestoreFromHash();
});

/* ===== GitHubå…¬é–‹ï¼ˆWorkerçµŒç”±ï¼‰ ===== */
async function pickPdfFile(){
  return new Promise((resolve)=>{
    const inp = document.createElement('input');
    inp.type = 'file'; inp.accept = 'application/pdf';
    inp.onchange = ()=> resolve(inp.files?.[0] || null);
    inp.click();
  });
}
function toBase64FromBytes(bytes){
  let bin=''; const arr = new Uint8Array(bytes);
  for (let i=0;i<arr.length;i++) bin += String.fromCharCode(arr[i]);
  return btoa(bin);
}
async function uploadPdfToGithub(file){
  const key = localStorage.getItem('APP_KEY') || prompt(APP_KEY_PROMPT) || '';
  if (!key) { alert('ã‚­ãƒ¼ãŒå¿…è¦ã§ã™'); return null; }
  localStorage.setItem('APP_KEY', key);

  const arr = new Uint8Array(await file.arrayBuffer());
  const b64 = toBase64FromBytes(arr);

  const teacher = prompt('å…ˆç”Ÿåï¼ˆç•¥å·ï¼‰', 'tanaka') || 'teacher';
  const aid     = prompt('èª²é¡Œã‚³ãƒ¼ãƒ‰', 'ws1') || 'assignment';

  const res = await fetch(UPLOAD_ENDPOINT, {
    method: 'POST',
    headers: { 'Content-Type':'application/json', 'X-App-Key': key },
    body: JSON.stringify({
      filename: file.name || 'worksheet.pdf',
      teacher, aid,
      pdf_base64: b64
    })
  });
  const data = await res.json();
  if (!data.ok) throw new Error(JSON.stringify(data));
  return data.raw_url;
}
ui.uploadPdfBtn.addEventListener('click', async ()=>{
  try{
    const file = await pickPdfFile();
    if(!file) return;
    const rawUrl = await uploadPdfToGithub(file);
    if(!rawUrl) return;

    const sp = new URLSearchParams(location.search);
    sp.set('pdf', rawUrl);
    history.replaceState(null, '', location.pathname + '?' + sp.toString() + location.hash);
    await autoLoadPdfFromQuery();

    const distUrl = location.origin + location.pathname + '?' + sp.toString();
    await navigator.clipboard?.writeText(distUrl);
    alert('PDFã‚’GitHubã«ä¿å­˜ã—ã€é…å¸ƒãƒªãƒ³ã‚¯ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼\n' + distUrl);
  }catch(e){
    console.error(e);
    alert('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸã€‚è¨­å®šï¼ˆAPP_KEY/ALLOW_ORIGIN ãªã©ï¼‰ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
  }
});

/* ===== åˆæœŸåŒ– ===== */
window.addEventListener('load', async ()=>{
  if (await tryRestoreFromHash()) return;
  await autoLoadPdfFromQuery();
  await drawPage();
});
window.addEventListener('resize', ()=> drawPage() );
</script>
</body>
</html>
