<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>手書きメモ（PDF注釈 / ESM版）</title>
  <link rel="icon" href="data:,"><!-- favicon 404回避 -->
  <style>
    html,body{height:100%;margin:0;font-family:system-ui}
    .app{display:grid;grid-template-rows:auto 1fr;height:100%}
    .toolbar{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;
             padding:.6rem;background:#f6f6f6;border-bottom:1px solid #ddd}
    .toolbar>*{background:#fff;border:1px solid #ddd;border-radius:.5rem;padding:.3rem .6rem}
    #stageWrap{position:relative;height:100%;min-height:360px;background:#fff}
    canvas{position:absolute;inset:0;width:100%;height:100%;touch-action:none;display:block}

    /* アクティブ状態の見た目（ペン/消しゴム） */
    .tool-btn{transition:.15s ease}
    .tool-btn.active{
      background:#e8f0fe;            /* 薄い青 */
      border-color:#6a9bff;
      box-shadow:0 0 0 2px #cfe0ff inset;
    }

    /* 色パレット */
    .palette button{
      width:24px;height:24px;border-radius:50%;padding:0;border:2px solid #ccc;cursor:pointer;
      display:inline-block; vertical-align:middle;
    }
    .palette button.sel{ box-shadow:0 0 0 3px #444 inset; border-color:#222; }
  </style>
</head>
<body>
<div class="app">
  <div class="toolbar">
    <label>太さ <input id="size" type="range" min="1" max="30" value="4"></label>
    <label>色 <input id="color" type="color" value="#111111"></label>

    <!-- 🎨 色パレット -->
    <div class="palette" id="palette">
      <button data-color="#000000" style="background:#000000" aria-label="黒"></button>
      <button data-color="#ff0000" style="background:#ff0000" aria-label="赤"></button>
      <button data-color="#0000ff" style="background:#0000ff" aria-label="青"></button>
      <button data-color="#008000" style="background:#008000" aria-label="緑"></button>
      <button data-color="#ffa500" style="background:#ffa500" aria-label="橙"></button>
      <button data-color="#ffff00" style="background:#ffff00" aria-label="黄"></button>
    </div>

    <button id="penBtn" class="tool-btn" aria-pressed="true">✒️ペン</button>
    <button id="eraserBtn" class="tool-btn" aria-pressed="false">🧽消しゴム</button>
    <label><input type="checkbox" id="penOnly">ペンのみ</label>
    <button id="undoBtn">↶Undo</button>
    <button id="redoBtn">↷Redo</button>
    <button id="clearBtn">🗑 全消去</button>
    <input type="file" id="pdfInput" accept="application/pdf">
    <button id="prevPage">◀</button>
    <span id="pageInfo">-/-</span>
    <button id="nextPage">▶</button>
    <button id="savePNGBtn">PNG保存</button>
  </div>

  <div id="stageWrap">
    <canvas id="pdfLayer"></canvas>
    <canvas id="inkLayer"></canvas>
  </div>
</div>

<script type="module">
  import * as pdfjsLib from './build/pdf.mjs';
  pdfjsLib.GlobalWorkerOptions.workerSrc = './build/pdf.worker.mjs';

  const pdfCanvas=document.getElementById('pdfLayer'),
        inkCanvas=document.getElementById('inkLayer'),
        pdfCtx=pdfCanvas.getContext('2d'),
        inkCtx=inkCanvas.getContext('2d'),
        dpr=window.devicePixelRatio||1;

  const ui={
    size:document.getElementById('size'),
    color:document.getElementById('color'),
    penBtn:document.getElementById('penBtn'),
    eraserBtn:document.getElementById('eraserBtn'),
    penOnly:document.getElementById('penOnly'),
    undoBtn:document.getElementById('undoBtn'),
    redoBtn:document.getElementById('redoBtn'),
    clearBtn:document.getElementById('clearBtn'),
    pdfInput:document.getElementById('pdfInput'),
    prev:document.getElementById('prevPage'),
    next:document.getElementById('nextPage'),
    info:document.getElementById('pageInfo'),
    savePNGBtn:document.getElementById('savePNGBtn'),
    paletteWrap:document.getElementById('palette'),
  };

  const state={
    tool:'pen', color:ui.color.value, size:+ui.size.value, penOnly:false,
    drawing:false, last:null, stroke:[], history:[], redoStack:[],
    pdf:null, page:1, totalPages:0
  };

  // ------- UI helpers -------
  function setActiveTool(tool){
    state.tool = tool;
    const isPen = tool==='pen';
    ui.penBtn.classList.toggle('active', isPen);
    ui.eraserBtn.classList.toggle('active', !isPen);
    ui.penBtn.setAttribute('aria-pressed', String(isPen));
    ui.eraserBtn.setAttribute('aria-pressed', String(!isPen));
  }
  // 起動時はペンをアクティブ表示
  setActiveTool('pen');

  function setSelectedPalette(color){
    state.color = color;
    ui.color.value = color; // カラーピッカーも同期
    // パレットの選択表示
    for(const btn of ui.paletteWrap.querySelectorAll('button')){
      btn.classList.toggle('sel', btn.dataset.color?.toLowerCase()===color.toLowerCase());
    }
  }
  // 初期色を反映
  setSelectedPalette(ui.color.value);

  // ------- layout -------
  function resize(){
    const wrap=document.getElementById('stageWrap');
    const cssW=wrap.clientWidth,
          cssH=Math.max(360, window.innerHeight - wrap.getBoundingClientRect().top);
    for(const c of [pdfCanvas,inkCanvas]){
      c.width=Math.floor(cssW*dpr); c.height=Math.floor(cssH*dpr);
      c.style.width=cssW+'px'; c.style.height=cssH+'px';
    }
    pdfCtx.setTransform(dpr,0,0,dpr,0,0);
    inkCtx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', ()=>{ resize(); if(state.pdf) drawPDF(); else redrawInk(); });

  // ------- draw -------
  function drawLine(ctx,a,b,opt){
    const pressure=b.pres??1, base=opt.size||state.size;
    const w=opt.pressure? base*pressure: base;
    const dx=b.x-a.x, dy=b.y-a.y, dist=Math.hypot(dx,dy);
    const STEP=2, steps=Math.max(1, Math.ceil(dist/STEP));
    ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle=opt.color||state.color; ctx.lineWidth=w;
    ctx.beginPath(); ctx.moveTo(a.x,a.y);
    for(let i=1;i<=steps;i++){ const t=i/steps; ctx.lineTo(a.x+dx*t, a.y+dy*t); }
    ctx.stroke();
  }
  function eraseLine(ctx,a,b,esize){
    ctx.save(); ctx.globalCompositeOperation='destination-out';
    drawLine(ctx,a,b,{color:'#000', size:esize||state.size*2, pressure:true});
    ctx.restore();
  }
  function getPos(e){ const r=inkCanvas.getBoundingClientRect(); return {x:e.clientX-r.left,y:e.clientY-r.top,pres:e.pressure>0?e.pressure:1}; }
  function begin(p){ state.drawing=true; state.last=p; state.stroke=[{p,tool:state.tool,color:state.color,size:state.size}]; }
  function move(p){
    if(!state.drawing) return;
    const a=state.last,b=p;
    if(state.tool==='pen') drawLine(inkCtx,a,b,{pressure:true});
    else eraseLine(inkCtx,a,b);
    state.stroke.push({p,tool:state.tool,color:state.color,size:state.size});
    state.last=b;
  }
  function end(){
    if(!state.drawing) return;
    state.drawing=false; state.history.push({ops:state.stroke}); state.redoStack=[];
  }

  inkCanvas.addEventListener('pointerdown',e=>{ if(state.penOnly&&e.pointerType!=='pen')return; inkCanvas.setPointerCapture(e.pointerId); begin(getPos(e)); });
  inkCanvas.addEventListener('pointermove',e=>{ if(state.penOnly&&e.pointerType!=='pen')return; if(state.drawing) move(getPos(e)); });
  ['pointerup','pointercancel','pointerout','pointerleave'].forEach(t=> inkCanvas.addEventListener(t,end));

  // ------- history -------
  function redrawInk(){
    inkCtx.clearRect(0,0,inkCanvas.width/dpr,inkCanvas.height/dpr);
    state.history.forEach(h=>{
      for(let i=1;i<h.ops.length;i++){
        const A=h.ops[i-1],B=h.ops[i];
        if(B.tool==='pen') drawLine(inkCtx,A.p,B.p,{color:A.color,size:A.size});
        else eraseLine(inkCtx,A.p,B.p,(A.size||state.size)*2);
      }
    });
  }
  function undo(){ if(state.history.length){ state.redoStack.push(state.history.pop()); redrawInk(); } }
  function redo(){ if(state.redoStack.length){ state.history.push(state.redoStack.pop()); redrawInk(); } }

  // ------- PDF -------
  function drawPDF(){
    if(!state.pdf) return;
    const wrap=document.getElementById('stageWrap');
    const targetWidth=Math.max(1, wrap.clientWidth);
    state.pdf.getPage(state.page).then(p=>{
      const v=p.getViewport({scale:1});
      const scale=targetWidth / v.width;
      const vp=p.getViewport({scale});
      pdfCanvas.width=Math.floor(vp.width*dpr); pdfCanvas.height=Math.floor(vp.height*dpr);
      inkCanvas.width=Math.floor(vp.width*dpr); inkCanvas.height=Math.floor(vp.height*dpr);
      pdfCanvas.style.width=vp.width+'px'; pdfCanvas.style.height=vp.height+'px';
      inkCanvas.style.width=vp.width+'px'; inkCanvas.style.height=vp.height+'px';
      pdfCtx.setTransform(dpr,0,0,dpr,0,0); inkCtx.setTransform(dpr,0,0,dpr,0,0);
      p.render({canvasContext:pdfCtx,viewport:vp}).promise.then(()=> redrawInk());
      ui.info.textContent=`${state.page}/${state.totalPages}`;
    });
  }

  // ------- events -------
  ui.size.addEventListener('input', ()=> state.size=+ui.size.value);
  ui.color.addEventListener('input', ()=> setSelectedPalette(ui.color.value));

  ui.paletteWrap.addEventListener('click', (e)=>{
    const btn = e.target.closest('button[data-color]');
    if(!btn) return;
    setSelectedPalette(btn.dataset.color);
  });

  ui.penOnly.addEventListener('change', e=> state.penOnly=e.target.checked);
  ui.penBtn.onclick = ()=> setActiveTool('pen');
  ui.eraserBtn.onclick = ()=> setActiveTool('eraser');

  // キーボードでも切替（p = ペン / e = 消しゴム）
  window.addEventListener('keydown', (e)=>{
    if(e.key.toLowerCase()==='p') setActiveTool('pen');
    if(e.key.toLowerCase()==='e') setActiveTool('eraser');
  });

  ui.undoBtn.onclick=undo;
  ui.redoBtn.onclick=redo;

  ui.clearBtn.onclick=()=>{
    if(confirm('手書きの内容をすべて消去します。よろしいですか？')){
      state.history=[]; state.redoStack=[];
      inkCtx.clearRect(0,0,inkCanvas.width/dpr,inkCanvas.height/dpr);
      if(state.pdf) drawPDF();
    }
  };

  ui.pdfInput.onchange=async e=>{
    const f=e.target.files?.[0]; if(!f) return;
    try{
      const buf=await f.arrayBuffer();
      state.pdf=await pdfjsLib.getDocument({data:buf}).promise;
      state.totalPages=state.pdf.numPages; state.page=1;
      drawPDF();
    }catch(err){ console.error(err); alert('PDF読み込み失敗: '+(err.message||err)); }
  };

  ui.prev.onclick=()=>{ if(state.pdf && state.page>1){ state.page--; drawPDF(); } };
  ui.next.onclick=()=>{ if(state.pdf && state.page<state.totalPages){ state.page++; drawPDF(); } };

  ui.savePNGBtn.onclick=()=>{
    const out=document.createElement('canvas'); out.width=pdfCanvas.width; out.height=pdfCanvas.height;
    const o=out.getContext('2d'); o.drawImage(pdfCanvas,0,0); o.drawImage(inkCanvas,0,0);
    const a=document.createElement('a'); a.href=out.toDataURL('image/png'); a.download='note.png'; a.click();
  };

  window.addEventListener('load', ()=>{ resize(); });
</script>
</body>
</html>
